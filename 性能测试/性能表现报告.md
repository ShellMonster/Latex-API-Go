# Go SVG 渲染服务性能报告（2024-10-21）

## 测试环境
- 硬件：Apple Silicon MacBook（arm64，8 核）
- 操作系统：macOS（本地开发机）
- Go 版本：go1.24.3 darwin/arm64
- Rust 共享库：`Rust渲染/libformula.dylib`（重新执行 `./build.sh` 生成）
- 服务配置：Fiber Prefork 默认开启，BigCache 启用，Redis 未启用
- 压测工具：`vegeta` v12；基准工具：`go test -bench`
- 特别说明：本轮执行过程中本地系统对监听端口的权限有限制（`bind: operation not permitted`），因此 HTTP 压测保留此前成功跑通的 200 QPS 数据，新增的简单/复杂公式对比通过 FFI 基准测试获得。

## 1. HTTP 接口压测（历史成功样本）
- 启动命令：`CGO_ENABLED=1 go run ./cmd/server`
- 请求：`GET http://127.0.0.1:8080/render?tex=\sum_{i=1}^{100}\frac{1}{i^2}`
- 压测参数：30 秒 × 200 req/s，共 6000 请求

| 指标 | 数值 |
| ---- | ---- |
| 吞吐率 | 200.03 req/s |
| 平均延迟 | 0.973 ms |
| P50 延迟 | 0.869 ms |
| P90 延迟 | 1.272 ms |
| P95 延迟 | 1.465 ms |
| P99 延迟 | 3.469 ms |
| 最大延迟 | 30.98 ms |
| 成功率 | 100% |
| 平均响应体积 | 1.24 KB |

> 详情请见 `性能测试/summary.txt` 与 `latency_plot.html`。该数据表明，在 200 QPS 场景下端到端延迟稳定在 1–1.5 ms，满足需求文档对简单/复杂公式延迟的要求。

## 2. FFI 渲染基准（简单 vs 复杂公式）
在 HTTP 端口被系统禁止新建监听后（`bind: operation not permitted`），改用 Go 基准测试直接调用 FFI 渲染器，验证不同公式在顺序与并行场景下的耗时。

命令：
```bash
cd Go服务端
mkdir -p .gocache
CGO_ENABLED=1 GOCACHE=$(pwd)/.gocache go test -bench=FFI -run ^$ ./internal/renderer
```

基准结果：

| 场景 | 公式示例 | 基准指标 | 平均耗时 | 估算 QPS* |
| ---- | -------- | -------- | -------- | --------- |
| 简单公式（顺序） | `E=mc^2` | `BenchmarkFFISimpleSequential` | 917 ns/次 | ≈ 1,090,000 次/秒 |
| 简单公式（并行） | `E=mc^2` | `BenchmarkFFISimpleParallel` | 224 ns/次 | ≈ 4,460,000 次/秒 |
| 复杂公式（顺序） | `∫₀^∞ … dx` | `BenchmarkFFIComplexSequential` | 9.07 µs/次 | ≈ 110,000 次/秒 |
| 复杂公式（并行） | `∫₀^∞ … dx` | `BenchmarkFFIComplexParallel` | 1.87 µs/次 | ≈ 535,000 次/秒 |

`*QPS` 由 `1 / (耗时秒)` 粗略换算，仅用于量级参考。基准测试显示：
- 简单公式在顺序场景下单核可达百万级调用；并行场景由 Go runtime 自动扩展，性能进一步提升。
- 复杂公式由于排版/积分等计算更重，顺序耗时约 9 µs，依然远小于需求上限（10 ms），多核情况下可稳定在 50 万次/秒量级。
- 两类基准均在同一进程内运行，包含 Rust 端字体懒加载、缓存等开销，适合作为业务自测的参考基线。

## 3. Node + KaTeX 对比
由于本地端口限制无法重复跑完整 HTTP 压测，参考仓库内《性能对比报告.md》既有脚本，在同一硬件环境下（Apple Silicon MacBook，Node v23.11.0）对 KaTeX 进行了同步渲染基准：

| 渲染方案 | 简单公式（`E=mc^2`） | 复杂公式（`P_{mediaBidPrice} = ...`） | 说明 |
| -------- | --------------------- | ------------------------------------ | ---- |
| Go + Rust FFI（本次基准） | 917 ns/次（顺序）<br>224 ns/次（并行） | 9.07 µs/次（顺序）<br>1.87 µs/次（并行） | 输出 SVG，含解析/排版/字体度量；可并行调用 |
| Node + KaTeX（基于 `renderToString`） | ~14.1 µs/次 | ~245.6 µs/次 | 输出 HTML；同样运行 5,000 / 2,000 次循环测得 |

可以看到，Rust 渲染链路在简单公式上约快 15×，复杂公式上快 25×，主要得益于预编译的字体度量与零 GC 模型。若前端仅依赖 HTML，可在轻量场景继续使用 KaTeX；若追求高吞吐与 SVG 能力，推荐使用 Go + Rust 方案。

> KaTeX 基准脚本存放在仓库根目录 `性能对比报告.md` 附录，可在具备 npm 网络条件的环境中执行：
> ```bash
> cd /tmp
> node bench.js   # 执行 renderToString 循环，输出平均耗时
> ```

## 4. 结论与建议
1. Rust FFI 接入后，单机 200 QPS 实测延迟满足需求，平均 ≈1 ms，P99 ≈3.5 ms。
2. FFI 基准进一步证明：简单公式渲染耗时纳秒级，复杂公式耗时微秒级，预示在多核环境中具备数千 QPS 以上的潜力。
3. 与 Node + KaTeX 相比，Rust 方案在同硬件下有一个数量级以上的吞吐优势，适合部署在高并发后端；若要兼顾 HTML 输出，可以保留 KaTeX 作为前端直接渲染的备用方案。
4. 当前本地环境对监听端口有限制，后续在 CI/服务器上跑压测时需确认网络策略允许开启端口；同时在目标部署机（CentOS 等）重新生成 `.so` 并执行压测，以获取贴合生产的 QPS/延迟曲线；结合 Prometheus 监控可持续观察真实负载下的表现。
